// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v6.30.2
// source: schema.proto

package git_pages

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Type int32

const (
	// Invalid entry.
	Type_InvalidEntry Type = 0
	// Directory.
	Type_Directory Type = 1
	// Inline file. `Blob.Data` contains file contents.
	Type_InlineFile Type = 2
	// External file. `Blob.Data` contains object reference.
	Type_ExternalFile Type = 3
	// Symlink. `Blob.Data` contains relative path.
	Type_Symlink Type = 4
)

// Enum value maps for Type.
var (
	Type_name = map[int32]string{
		0: "InvalidEntry",
		1: "Directory",
		2: "InlineFile",
		3: "ExternalFile",
		4: "Symlink",
	}
	Type_value = map[string]int32{
		"InvalidEntry": 0,
		"Directory":    1,
		"InlineFile":   2,
		"ExternalFile": 3,
		"Symlink":      4,
	}
)

func (x Type) Enum() *Type {
	p := new(Type)
	*p = x
	return p
}

func (x Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Type) Descriptor() protoreflect.EnumDescriptor {
	return file_schema_proto_enumTypes[0].Descriptor()
}

func (Type) Type() protoreflect.EnumType {
	return &file_schema_proto_enumTypes[0]
}

func (x Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Type.Descriptor instead.
func (Type) EnumDescriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{0}
}

// Transformation names should match HTTP `Accept-Encoding:` header.
type Transform int32

const (
	// No transformation.
	Transform_Identity Transform = 0
	// Zstandard compression.
	Transform_Zstd Transform = 1
)

// Enum value maps for Transform.
var (
	Transform_name = map[int32]string{
		0: "Identity",
		1: "Zstd",
	}
	Transform_value = map[string]int32{
		"Identity": 0,
		"Zstd":     1,
	}
)

func (x Transform) Enum() *Transform {
	p := new(Transform)
	*p = x
	return p
}

func (x Transform) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Transform) Descriptor() protoreflect.EnumDescriptor {
	return file_schema_proto_enumTypes[1].Descriptor()
}

func (Transform) Type() protoreflect.EnumType {
	return &file_schema_proto_enumTypes[1]
}

func (x Transform) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Transform.Descriptor instead.
func (Transform) EnumDescriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{1}
}

type AuditEvent int32

const (
	// Invalid event.
	AuditEvent_InvalidEvent AuditEvent = 0
	// A manifest was committed (a site was created or updated).
	AuditEvent_CommitManifest AuditEvent = 1
	// A manifest was deleted (a site was deleted).
	AuditEvent_DeleteManifest AuditEvent = 2
	// A domain was frozen.
	AuditEvent_FreezeDomain AuditEvent = 3
	// A domain was thawed.
	AuditEvent_UnfreezeDomain AuditEvent = 4
)

// Enum value maps for AuditEvent.
var (
	AuditEvent_name = map[int32]string{
		0: "InvalidEvent",
		1: "CommitManifest",
		2: "DeleteManifest",
		3: "FreezeDomain",
		4: "UnfreezeDomain",
	}
	AuditEvent_value = map[string]int32{
		"InvalidEvent":   0,
		"CommitManifest": 1,
		"DeleteManifest": 2,
		"FreezeDomain":   3,
		"UnfreezeDomain": 4,
	}
)

func (x AuditEvent) Enum() *AuditEvent {
	p := new(AuditEvent)
	*p = x
	return p
}

func (x AuditEvent) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AuditEvent) Descriptor() protoreflect.EnumDescriptor {
	return file_schema_proto_enumTypes[2].Descriptor()
}

func (AuditEvent) Type() protoreflect.EnumType {
	return &file_schema_proto_enumTypes[2]
}

func (x AuditEvent) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AuditEvent.Descriptor instead.
func (AuditEvent) EnumDescriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{2}
}

type Entry struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Type  *Type                  `protobuf:"varint,1,opt,name=type,enum=Type" json:"type,omitempty"`
	// Only present for `type == InlineFile` and `type == ExternalFile`.
	// For transformed entries, refers to the pre-transformation (decompressed) size; otherwise
	// equal to `compressed_size`.
	OriginalSize *int64 `protobuf:"varint,7,opt,name=original_size,json=originalSize" json:"original_size,omitempty"`
	// Only present for `type == InlineFile` and `type == ExternalFile`.
	// For transformed entries, refers to the post-transformation (compressed) size; otherwise
	// equal to `original_size`.
	CompressedSize *int64 `protobuf:"varint,2,opt,name=compressed_size,json=compressedSize" json:"compressed_size,omitempty"`
	// Meaning depends on `type`:
	//   - If `type == InlineFile`, contains file data.
	//   - If `type == ExternalFile`, contains blob name (an otherwise unspecified
	//     cryptographically secure content hash).
	//   - If `type == Symlink`, contains link target.
	//   - Otherwise not present.
	Data []byte `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
	// Only present for `type == InlineFile` and `type == ExternalFile` that
	// have been transformed.
	Transform *Transform `protobuf:"varint,4,opt,name=transform,enum=Transform" json:"transform,omitempty"`
	// Only present for `type == InlineFile` and `type == ExternalFile`.
	// Currently, optional (not present on certain legacy manifests).
	ContentType *string `protobuf:"bytes,5,opt,name=content_type,json=contentType" json:"content_type,omitempty"`
	// May be present for `type == InlineFile` and `type == ExternalFile`.
	// Used to reduce the amount of work being done during git checkouts.
	// The type of hash used is determined by the length:
	//   - 40 bytes: SHA1DC (as hex)
	//   - 64 bytes: SHA256 (as hex)
	GitHash       *string `protobuf:"bytes,6,opt,name=git_hash,json=gitHash" json:"git_hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Entry) Reset() {
	*x = Entry{}
	mi := &file_schema_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Entry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Entry) ProtoMessage() {}

func (x *Entry) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Entry.ProtoReflect.Descriptor instead.
func (*Entry) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{0}
}

func (x *Entry) GetType() Type {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return Type_InvalidEntry
}

func (x *Entry) GetOriginalSize() int64 {
	if x != nil && x.OriginalSize != nil {
		return *x.OriginalSize
	}
	return 0
}

func (x *Entry) GetCompressedSize() int64 {
	if x != nil && x.CompressedSize != nil {
		return *x.CompressedSize
	}
	return 0
}

func (x *Entry) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *Entry) GetTransform() Transform {
	if x != nil && x.Transform != nil {
		return *x.Transform
	}
	return Transform_Identity
}

func (x *Entry) GetContentType() string {
	if x != nil && x.ContentType != nil {
		return *x.ContentType
	}
	return ""
}

func (x *Entry) GetGitHash() string {
	if x != nil && x.GitHash != nil {
		return *x.GitHash
	}
	return ""
}

// See https://docs.netlify.com/manage/routing/redirects/overview/ for details.
// Only a subset of the Netlify specification is representable here.
type RedirectRule struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	From          *string                `protobuf:"bytes,1,opt,name=from" json:"from,omitempty"`
	To            *string                `protobuf:"bytes,2,opt,name=to" json:"to,omitempty"`
	Status        *uint32                `protobuf:"varint,3,opt,name=status" json:"status,omitempty"`
	Force         *bool                  `protobuf:"varint,4,opt,name=force" json:"force,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RedirectRule) Reset() {
	*x = RedirectRule{}
	mi := &file_schema_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RedirectRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RedirectRule) ProtoMessage() {}

func (x *RedirectRule) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RedirectRule.ProtoReflect.Descriptor instead.
func (*RedirectRule) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{1}
}

func (x *RedirectRule) GetFrom() string {
	if x != nil && x.From != nil {
		return *x.From
	}
	return ""
}

func (x *RedirectRule) GetTo() string {
	if x != nil && x.To != nil {
		return *x.To
	}
	return ""
}

func (x *RedirectRule) GetStatus() uint32 {
	if x != nil && x.Status != nil {
		return *x.Status
	}
	return 0
}

func (x *RedirectRule) GetForce() bool {
	if x != nil && x.Force != nil {
		return *x.Force
	}
	return false
}

// See https://docs.netlify.com/manage/routing/headers/ for details.
type Header struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          *string                `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Values        []string               `protobuf:"bytes,2,rep,name=values" json:"values,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Header) Reset() {
	*x = Header{}
	mi := &file_schema_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Header) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Header) ProtoMessage() {}

func (x *Header) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Header.ProtoReflect.Descriptor instead.
func (*Header) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{2}
}

func (x *Header) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *Header) GetValues() []string {
	if x != nil {
		return x.Values
	}
	return nil
}

type HeaderRule struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Path          *string                `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	HeaderMap     []*Header              `protobuf:"bytes,2,rep,name=header_map,json=headerMap" json:"header_map,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeaderRule) Reset() {
	*x = HeaderRule{}
	mi := &file_schema_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeaderRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeaderRule) ProtoMessage() {}

func (x *HeaderRule) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeaderRule.ProtoReflect.Descriptor instead.
func (*HeaderRule) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{3}
}

func (x *HeaderRule) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

func (x *HeaderRule) GetHeaderMap() []*Header {
	if x != nil {
		return x.HeaderMap
	}
	return nil
}

type Problem struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Path          *string                `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Cause         *string                `protobuf:"bytes,2,opt,name=cause" json:"cause,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Problem) Reset() {
	*x = Problem{}
	mi := &file_schema_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Problem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Problem) ProtoMessage() {}

func (x *Problem) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Problem.ProtoReflect.Descriptor instead.
func (*Problem) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{4}
}

func (x *Problem) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

func (x *Problem) GetCause() string {
	if x != nil && x.Cause != nil {
		return *x.Cause
	}
	return ""
}

type Manifest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Source metadata.
	RepoUrl *string `protobuf:"bytes,1,opt,name=repo_url,json=repoUrl" json:"repo_url,omitempty"`
	Branch  *string `protobuf:"bytes,2,opt,name=branch" json:"branch,omitempty"`
	Commit  *string `protobuf:"bytes,3,opt,name=commit" json:"commit,omitempty"`
	// Site contents.
	Contents       map[string]*Entry `protobuf:"bytes,4,rep,name=contents" json:"contents,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	OriginalSize   *int64            `protobuf:"varint,10,opt,name=original_size,json=originalSize" json:"original_size,omitempty"`      // sum of each `entry.original_size`
	CompressedSize *int64            `protobuf:"varint,5,opt,name=compressed_size,json=compressedSize" json:"compressed_size,omitempty"` // sum of each `entry.compressed_size`
	StoredSize     *int64            `protobuf:"varint,8,opt,name=stored_size,json=storedSize" json:"stored_size,omitempty"`             // sum of deduplicated `entry.compressed_size` for external files only
	// Netlify-style `_redirects` and `_headers` rules.
	Redirects []*RedirectRule `protobuf:"bytes,6,rep,name=redirects" json:"redirects,omitempty"`
	Headers   []*HeaderRule   `protobuf:"bytes,9,rep,name=headers" json:"headers,omitempty"`
	// Diagnostics for non-fatal errors.
	Problems      []*Problem `protobuf:"bytes,7,rep,name=problems" json:"problems,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Manifest) Reset() {
	*x = Manifest{}
	mi := &file_schema_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Manifest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Manifest) ProtoMessage() {}

func (x *Manifest) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Manifest.ProtoReflect.Descriptor instead.
func (*Manifest) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{5}
}

func (x *Manifest) GetRepoUrl() string {
	if x != nil && x.RepoUrl != nil {
		return *x.RepoUrl
	}
	return ""
}

func (x *Manifest) GetBranch() string {
	if x != nil && x.Branch != nil {
		return *x.Branch
	}
	return ""
}

func (x *Manifest) GetCommit() string {
	if x != nil && x.Commit != nil {
		return *x.Commit
	}
	return ""
}

func (x *Manifest) GetContents() map[string]*Entry {
	if x != nil {
		return x.Contents
	}
	return nil
}

func (x *Manifest) GetOriginalSize() int64 {
	if x != nil && x.OriginalSize != nil {
		return *x.OriginalSize
	}
	return 0
}

func (x *Manifest) GetCompressedSize() int64 {
	if x != nil && x.CompressedSize != nil {
		return *x.CompressedSize
	}
	return 0
}

func (x *Manifest) GetStoredSize() int64 {
	if x != nil && x.StoredSize != nil {
		return *x.StoredSize
	}
	return 0
}

func (x *Manifest) GetRedirects() []*RedirectRule {
	if x != nil {
		return x.Redirects
	}
	return nil
}

func (x *Manifest) GetHeaders() []*HeaderRule {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *Manifest) GetProblems() []*Problem {
	if x != nil {
		return x.Problems
	}
	return nil
}

type AuditRecord struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Audit event metadata.
	Id        *int64                 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	Timestamp *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp,omitempty"`
	Event     *AuditEvent            `protobuf:"varint,3,opt,name=event,enum=AuditEvent" json:"event,omitempty"`
	Principal *Principal             `protobuf:"bytes,4,opt,name=principal" json:"principal,omitempty"`
	// Affected resource.
	Domain  *string `protobuf:"bytes,10,opt,name=domain" json:"domain,omitempty"`
	Project *string `protobuf:"bytes,11,opt,name=project" json:"project,omitempty"` // only for `*Manifest` events
	// Snapshot of site manifest.
	Manifest      *Manifest `protobuf:"bytes,12,opt,name=manifest" json:"manifest,omitempty"` // only for `*Manifest` events
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AuditRecord) Reset() {
	*x = AuditRecord{}
	mi := &file_schema_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuditRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuditRecord) ProtoMessage() {}

func (x *AuditRecord) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuditRecord.ProtoReflect.Descriptor instead.
func (*AuditRecord) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{6}
}

func (x *AuditRecord) GetId() int64 {
	if x != nil && x.Id != nil {
		return *x.Id
	}
	return 0
}

func (x *AuditRecord) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *AuditRecord) GetEvent() AuditEvent {
	if x != nil && x.Event != nil {
		return *x.Event
	}
	return AuditEvent_InvalidEvent
}

func (x *AuditRecord) GetPrincipal() *Principal {
	if x != nil {
		return x.Principal
	}
	return nil
}

func (x *AuditRecord) GetDomain() string {
	if x != nil && x.Domain != nil {
		return *x.Domain
	}
	return ""
}

func (x *AuditRecord) GetProject() string {
	if x != nil && x.Project != nil {
		return *x.Project
	}
	return ""
}

func (x *AuditRecord) GetManifest() *Manifest {
	if x != nil {
		return x.Manifest
	}
	return nil
}

type Principal struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	IpAddress     *string                `protobuf:"bytes,1,opt,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Principal) Reset() {
	*x = Principal{}
	mi := &file_schema_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Principal) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Principal) ProtoMessage() {}

func (x *Principal) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Principal.ProtoReflect.Descriptor instead.
func (*Principal) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{7}
}

func (x *Principal) GetIpAddress() string {
	if x != nil && x.IpAddress != nil {
		return *x.IpAddress
	}
	return ""
}

var File_schema_proto protoreflect.FileDescriptor

const file_schema_proto_rawDesc = "" +
	"\n" +
	"\fschema.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xec\x01\n" +
	"\x05Entry\x12\x19\n" +
	"\x04type\x18\x01 \x01(\x0e2\x05.TypeR\x04type\x12#\n" +
	"\roriginal_size\x18\a \x01(\x03R\foriginalSize\x12'\n" +
	"\x0fcompressed_size\x18\x02 \x01(\x03R\x0ecompressedSize\x12\x12\n" +
	"\x04data\x18\x03 \x01(\fR\x04data\x12(\n" +
	"\ttransform\x18\x04 \x01(\x0e2\n" +
	".TransformR\ttransform\x12!\n" +
	"\fcontent_type\x18\x05 \x01(\tR\vcontentType\x12\x19\n" +
	"\bgit_hash\x18\x06 \x01(\tR\agitHash\"`\n" +
	"\fRedirectRule\x12\x12\n" +
	"\x04from\x18\x01 \x01(\tR\x04from\x12\x0e\n" +
	"\x02to\x18\x02 \x01(\tR\x02to\x12\x16\n" +
	"\x06status\x18\x03 \x01(\rR\x06status\x12\x14\n" +
	"\x05force\x18\x04 \x01(\bR\x05force\"4\n" +
	"\x06Header\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x16\n" +
	"\x06values\x18\x02 \x03(\tR\x06values\"H\n" +
	"\n" +
	"HeaderRule\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x12&\n" +
	"\n" +
	"header_map\x18\x02 \x03(\v2\a.HeaderR\theaderMap\"3\n" +
	"\aProblem\x12\x12\n" +
	"\x04path\x18\x01 \x01(\tR\x04path\x12\x14\n" +
	"\x05cause\x18\x02 \x01(\tR\x05cause\"\xb8\x03\n" +
	"\bManifest\x12\x19\n" +
	"\brepo_url\x18\x01 \x01(\tR\arepoUrl\x12\x16\n" +
	"\x06branch\x18\x02 \x01(\tR\x06branch\x12\x16\n" +
	"\x06commit\x18\x03 \x01(\tR\x06commit\x123\n" +
	"\bcontents\x18\x04 \x03(\v2\x17.Manifest.ContentsEntryR\bcontents\x12#\n" +
	"\roriginal_size\x18\n" +
	" \x01(\x03R\foriginalSize\x12'\n" +
	"\x0fcompressed_size\x18\x05 \x01(\x03R\x0ecompressedSize\x12\x1f\n" +
	"\vstored_size\x18\b \x01(\x03R\n" +
	"storedSize\x12+\n" +
	"\tredirects\x18\x06 \x03(\v2\r.RedirectRuleR\tredirects\x12%\n" +
	"\aheaders\x18\t \x03(\v2\v.HeaderRuleR\aheaders\x12$\n" +
	"\bproblems\x18\a \x03(\v2\b.ProblemR\bproblems\x1aC\n" +
	"\rContentsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x1c\n" +
	"\x05value\x18\x02 \x01(\v2\x06.EntryR\x05value:\x028\x01\"\xfd\x01\n" +
	"\vAuditRecord\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x03R\x02id\x128\n" +
	"\ttimestamp\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12!\n" +
	"\x05event\x18\x03 \x01(\x0e2\v.AuditEventR\x05event\x12(\n" +
	"\tprincipal\x18\x04 \x01(\v2\n" +
	".PrincipalR\tprincipal\x12\x16\n" +
	"\x06domain\x18\n" +
	" \x01(\tR\x06domain\x12\x18\n" +
	"\aproject\x18\v \x01(\tR\aproject\x12%\n" +
	"\bmanifest\x18\f \x01(\v2\t.ManifestR\bmanifest\"*\n" +
	"\tPrincipal\x12\x1d\n" +
	"\n" +
	"ip_address\x18\x01 \x01(\tR\tipAddress*V\n" +
	"\x04Type\x12\x10\n" +
	"\fInvalidEntry\x10\x00\x12\r\n" +
	"\tDirectory\x10\x01\x12\x0e\n" +
	"\n" +
	"InlineFile\x10\x02\x12\x10\n" +
	"\fExternalFile\x10\x03\x12\v\n" +
	"\aSymlink\x10\x04*#\n" +
	"\tTransform\x12\f\n" +
	"\bIdentity\x10\x00\x12\b\n" +
	"\x04Zstd\x10\x01*l\n" +
	"\n" +
	"AuditEvent\x12\x10\n" +
	"\fInvalidEvent\x10\x00\x12\x12\n" +
	"\x0eCommitManifest\x10\x01\x12\x12\n" +
	"\x0eDeleteManifest\x10\x02\x12\x10\n" +
	"\fFreezeDomain\x10\x03\x12\x12\n" +
	"\x0eUnfreezeDomain\x10\x04B,Z*codeberg.org/git-pages/git-pages/git_pagesb\beditionsp\xe8\a"

var (
	file_schema_proto_rawDescOnce sync.Once
	file_schema_proto_rawDescData []byte
)

func file_schema_proto_rawDescGZIP() []byte {
	file_schema_proto_rawDescOnce.Do(func() {
		file_schema_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_schema_proto_rawDesc), len(file_schema_proto_rawDesc)))
	})
	return file_schema_proto_rawDescData
}

var file_schema_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_schema_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_schema_proto_goTypes = []any{
	(Type)(0),                     // 0: Type
	(Transform)(0),                // 1: Transform
	(AuditEvent)(0),               // 2: AuditEvent
	(*Entry)(nil),                 // 3: Entry
	(*RedirectRule)(nil),          // 4: RedirectRule
	(*Header)(nil),                // 5: Header
	(*HeaderRule)(nil),            // 6: HeaderRule
	(*Problem)(nil),               // 7: Problem
	(*Manifest)(nil),              // 8: Manifest
	(*AuditRecord)(nil),           // 9: AuditRecord
	(*Principal)(nil),             // 10: Principal
	nil,                           // 11: Manifest.ContentsEntry
	(*timestamppb.Timestamp)(nil), // 12: google.protobuf.Timestamp
}
var file_schema_proto_depIdxs = []int32{
	0,  // 0: Entry.type:type_name -> Type
	1,  // 1: Entry.transform:type_name -> Transform
	5,  // 2: HeaderRule.header_map:type_name -> Header
	11, // 3: Manifest.contents:type_name -> Manifest.ContentsEntry
	4,  // 4: Manifest.redirects:type_name -> RedirectRule
	6,  // 5: Manifest.headers:type_name -> HeaderRule
	7,  // 6: Manifest.problems:type_name -> Problem
	12, // 7: AuditRecord.timestamp:type_name -> google.protobuf.Timestamp
	2,  // 8: AuditRecord.event:type_name -> AuditEvent
	10, // 9: AuditRecord.principal:type_name -> Principal
	8,  // 10: AuditRecord.manifest:type_name -> Manifest
	3,  // 11: Manifest.ContentsEntry.value:type_name -> Entry
	12, // [12:12] is the sub-list for method output_type
	12, // [12:12] is the sub-list for method input_type
	12, // [12:12] is the sub-list for extension type_name
	12, // [12:12] is the sub-list for extension extendee
	0,  // [0:12] is the sub-list for field type_name
}

func init() { file_schema_proto_init() }
func file_schema_proto_init() {
	if File_schema_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_schema_proto_rawDesc), len(file_schema_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_schema_proto_goTypes,
		DependencyIndexes: file_schema_proto_depIdxs,
		EnumInfos:         file_schema_proto_enumTypes,
		MessageInfos:      file_schema_proto_msgTypes,
	}.Build()
	File_schema_proto = out.File
	file_schema_proto_goTypes = nil
	file_schema_proto_depIdxs = nil
}
